{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","dominate.js","src/dominate.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","dominate","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","copyAttributes","el","target","attr","attrs","attributes","len","setAttribute","name","value","copyScript","doc","script","createElement","async","text","textContent","parseDocument","markup","type","parser","DOMParser","newDoc","parseFromString","removeChild","documentElement","parseHTML","tag","html","innerHTML","parse","supportsDOMParserHTML","_el","xml","_el2","firstChild","lastChild","wrap","wrapMap","_default","depth","childNodes","frag","createDocumentFragment","appendChild","_ref","arguments","undefined","_ref$context","context","document","_ref$type","_ref$scripts","scripts","toLowerCase","match","tagNameRe","exec","createTextNode","trim","parent","elements","querySelectorAll","parentNode","replaceChild","Object","defineProperty","thead","col","tr","td","tbody","tfoot","colgroup","caption","th","split","forEach"],"mappings":"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","file":"dominate.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*! dominate v0.1.1 | https://github.com/ryanmorr/dominate */\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.dominate = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\nexports.default = dominate;\n// Regex to extract the tag name\nvar tagNameRe = /<([\\w-]+)/;\n\n// Determine if `DOMParser` supports 'text/html'\nvar supportsDOMParserHTML = function () {\n    try {\n        if (new DOMParser().parseFromString('', 'text/html')) {\n            return true;\n        }\n    } catch (e) {\n        return false;\n    }\n}();\n\n// Prevent the parser from ignoring certain\n// elements by wrapping them with the necessary\n// parent elements to appease XHTML compliance\n// (courtesy of jQuery: https://github.com/jquery/jquery/blob/master/src/manipulation/wrapMap.js)\nvar wrapMap = {\n    thead: [1, '<table>', '</table>'],\n    col: [2, '<table><colgroup>', '</colgroup></table>'],\n    tr: [2, '<table><tbody>', '</tbody></table>'],\n    td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n    _default: [0, '', '']\n};\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n// Support SVG elements\n'circle ellipse g image line path polygon polyline rect text'.split(' ').forEach(function (tag) {\n    wrapMap[tag] = [1, '<svg xmlns=\"http://www.w3.org/2000/svg\">', '</svg>'];\n});\n\n/**\r\n * Copy the attributes from one node to another\r\n *\r\n * @param {Element} el\r\n * @param {Element} target\r\n * @return {Element}\r\n * @api private\r\n */\nfunction copyAttributes(el, target) {\n    var attrs = target.attributes;\n    for (var i = 0, len = attrs.length, attr; i < len; i++) {\n        attr = attrs[i];\n        el.setAttribute(attr.name, attr.value);\n    }\n    return el;\n}\n\n/**\r\n * Create a script element that will execute\r\n *\r\n * @param {Document} doc\r\n * @param {Element} el\r\n * @return {Element}\r\n * @api private\r\n */\nfunction copyScript(doc, el) {\n    var script = doc.createElement('script');\n    script.async = true;\n    script.text = el.textContent;\n    return copyAttributes(script, el);\n}\n\n/**\r\n * Parse HTML and XML documents\r\n *\r\n * @param {String} markup\r\n * @param {String} type\r\n * @return {Element}\r\n * @api private\r\n */\nfunction parseDocument(markup, type) {\n    var parser = new DOMParser();\n    var newDoc = parser.parseFromString(markup, type);\n    return newDoc.removeChild(newDoc.documentElement);\n}\n\n/**\r\n * Parse HTML string using the proper parent\r\n * element\r\n *\r\n * @param {Document} doc\r\n * @param {String} tag\r\n * @param {String} html\r\n * @return {Element}\r\n * @api private\r\n */\nfunction parseHTML(doc, tag, html) {\n    var el = doc.createElement(tag);\n    el.innerHTML = html;\n    return el;\n}\n\n/**\r\n * Parse an HMTL string into a DOM node\r\n *\r\n * @param {Document} doc\r\n * @param {String} tag\r\n * @param {String} html\r\n * @return {Element|DocumentFragment}\r\n * @api private\r\n */\nfunction parse(doc, tag, html) {\n    // Support <html> elements\n    if (tag === 'html') {\n        if (supportsDOMParserHTML) {\n            return parseDocument(html, 'text/html');\n        }\n        // Attributes of the <html> element do not get\n        // parsed using `innerHTML` here, so we parse it\n        // as XML and then copy the attributes\n        var _el = parseHTML(doc, 'html', html);\n        var xml = parseDocument(html, 'text/xml');\n        return copyAttributes(_el, xml);\n    }\n    // Support <body> and <head> elements\n    if (tag === 'head' || tag === 'body') {\n        var _el2 = parseHTML(doc, 'html', html);\n        return _el2.removeChild(tag === 'head' ? _el2.firstChild : _el2.lastChild);\n    }\n    // Wrap the element in the appropriate container\n    var wrap = wrapMap[tag] || wrapMap._default;\n    // Parse HTML string\n    var el = parseHTML(doc, 'div', wrap[1] + html + wrap[2]);\n    // Descend through wrappers to get the right element\n    var depth = wrap[0];\n    while (depth--) {\n        el = el.lastChild;\n    }\n    // Support executable <script> elements\n    if (tag === 'script') {\n        return copyScript(doc, el.firstChild);\n    }\n    // Single element\n    if (el.childNodes.length === 1) {\n        return el.removeChild(el.firstChild);\n    }\n    // Use a document fragment for multiple elements\n    var frag = doc.createDocumentFragment();\n    while (el.firstChild) {\n        frag.appendChild(el.firstChild);\n    }\n    return frag;\n}\n\n/**\r\n * Convert a string into a DOM node\r\n *\r\n * @param {String} html\r\n * @param {Object} options\r\n * @param {Document} options.context\r\n * @param {String} options.type\r\n * @param {Boolean} options.scripts\r\n * @return {Element|TextNode|DocumentFragment}\r\n * @api public\r\n */\nfunction dominate(html) {\n    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    var _ref$context = _ref.context;\n    var context = _ref$context === undefined ? document : _ref$context;\n    var _ref$type = _ref.type;\n    var type = _ref$type === undefined ? 'html' : _ref$type;\n    var _ref$scripts = _ref.scripts;\n    var scripts = _ref$scripts === undefined ? true : _ref$scripts;\n\n    // Return an XML element if the type param is 'xml'\n    if (type.toLowerCase() === 'xml') {\n        return parseDocument(html, 'text/xml');\n    }\n    // Parse the HTML string for a tag name\n    var match = tagNameRe.exec(html);\n    // If no tag name exists, treat it as plain text\n    if (!match) {\n        return context.createTextNode(html);\n    }\n    // Get the tag name\n    var tag = match[1].toLowerCase();\n    // Parse the HTML string into a DOM node\n    var el = parse(context, tag, html.trim());\n    // If it's a script element, return it as it\n    // should always execute regardless of the\n    // `scripts` param\n    if (tag === 'script') {\n        return el;\n    }\n    // If `scripts` param is true, replace all script\n    // elements with a new script element to enable\n    // execution, otherwise remove the script elements\n    var elements = el.querySelectorAll('script');\n    for (var i = 0, len = elements.length, script, parent; i < len; i++) {\n        script = elements[i];\n        parent = script.parentNode;\n        if (scripts === false) {\n            parent.removeChild(script);\n        } else {\n            parent.replaceChild(copyScript(context, script), script);\n        }\n    }\n    return el;\n}\nmodule.exports = exports['default'];\n\n},{}]},{},[1])(1)\n});\n\n","// Regex to extract the tag name\r\nconst tagNameRe = /<([\\w-]+)/;\r\n\r\n// Determine if `DOMParser` supports 'text/html'\r\nconst supportsDOMParserHTML = (() => {\r\n    try {\r\n        if ((new DOMParser()).parseFromString('', 'text/html')) {\r\n            return true;\r\n        }\r\n    } catch (e) {\r\n        return false;\r\n    }\r\n})();\r\n\r\n// Prevent the parser from ignoring certain\r\n// elements by wrapping them with the necessary\r\n// parent elements to appease XHTML compliance\r\n// (courtesy of jQuery: https://github.com/jquery/jquery/blob/master/src/manipulation/wrapMap.js)\r\nconst wrapMap = {\r\n    thead: [1, '<table>', '</table>'],\r\n    col: [2, '<table><colgroup>', '</colgroup></table>'],\r\n    tr: [2, '<table><tbody>', '</tbody></table>'],\r\n    td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\r\n    _default: [0, '', '']\r\n};\r\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\r\nwrapMap.th = wrapMap.td;\r\n\r\n// Support SVG elements\r\n'circle ellipse g image line path polygon polyline rect text'.split(' ').forEach((tag) => {\r\n    wrapMap[tag] = [1, '<svg xmlns=\"http://www.w3.org/2000/svg\">', '</svg>'];\r\n});\r\n\r\n/**\r\n * Copy the attributes from one node to another\r\n *\r\n * @param {Element} el\r\n * @param {Element} target\r\n * @return {Element}\r\n * @api private\r\n */\r\nfunction copyAttributes(el, target) {\r\n    const attrs = target.attributes;\r\n    for (let i = 0, len = attrs.length, attr; i < len; i++) {\r\n        attr = attrs[i];\r\n        el.setAttribute(attr.name, attr.value);\r\n    }\r\n    return el;\r\n}\r\n\r\n/**\r\n * Create a script element that will execute\r\n *\r\n * @param {Document} doc\r\n * @param {Element} el\r\n * @return {Element}\r\n * @api private\r\n */\r\nfunction copyScript(doc, el) {\r\n    const script = doc.createElement('script');\r\n    script.async = true;\r\n    script.text = el.textContent;\r\n    return copyAttributes(script, el);\r\n}\r\n\r\n/**\r\n * Parse HTML and XML documents\r\n *\r\n * @param {String} markup\r\n * @param {String} type\r\n * @return {Element}\r\n * @api private\r\n */\r\nfunction parseDocument(markup, type) {\r\n    const parser = new DOMParser();\r\n    const newDoc = parser.parseFromString(markup, type);\r\n    return newDoc.removeChild(newDoc.documentElement);\r\n}\r\n\r\n/**\r\n * Parse HTML string using the proper parent\r\n * element\r\n *\r\n * @param {Document} doc\r\n * @param {String} tag\r\n * @param {String} html\r\n * @return {Element}\r\n * @api private\r\n */\r\nfunction parseHTML(doc, tag, html) {\r\n    const el = doc.createElement(tag);\r\n    el.innerHTML = html;\r\n    return el;\r\n}\r\n\r\n/**\r\n * Parse an HMTL string into a DOM node\r\n *\r\n * @param {Document} doc\r\n * @param {String} tag\r\n * @param {String} html\r\n * @return {Element|DocumentFragment}\r\n * @api private\r\n */\r\nfunction parse(doc, tag, html) {\r\n    // Support <html> elements\r\n    if (tag === 'html') {\r\n        if (supportsDOMParserHTML) {\r\n            return parseDocument(html, 'text/html');\r\n        }\r\n        // Attributes of the <html> element do not get\r\n        // parsed using `innerHTML` here, so we parse it\r\n        // as XML and then copy the attributes\r\n        const el = parseHTML(doc, 'html', html);\r\n        const xml = parseDocument(html, 'text/xml');\r\n        return copyAttributes(el, xml);\r\n    }\r\n    // Support <body> and <head> elements\r\n    if (tag === 'head' || tag === 'body') {\r\n        const el = parseHTML(doc, 'html', html);\r\n        return el.removeChild(tag === 'head' ? el.firstChild : el.lastChild);\r\n    }\r\n    // Wrap the element in the appropriate container\r\n    const wrap = wrapMap[tag] || wrapMap._default;\r\n    // Parse HTML string\r\n    let el = parseHTML(doc, 'div', wrap[1] + html + wrap[2]);\r\n    // Descend through wrappers to get the right element\r\n    let depth = wrap[0];\r\n    while (depth--) {\r\n        el = el.lastChild;\r\n    }\r\n    // Support executable <script> elements\r\n    if (tag === 'script') {\r\n        return copyScript(doc, el.firstChild);\r\n    }\r\n    // Single element\r\n    if (el.childNodes.length === 1) {\r\n        return el.removeChild(el.firstChild);\r\n    }\r\n    // Use a document fragment for multiple elements\r\n    const frag = doc.createDocumentFragment();\r\n    while (el.firstChild) {\r\n        frag.appendChild(el.firstChild);\r\n    }\r\n    return frag;\r\n}\r\n\r\n/**\r\n * Convert a string into a DOM node\r\n *\r\n * @param {String} html\r\n * @param {Object} options\r\n * @param {Document} options.context\r\n * @param {String} options.type\r\n * @param {Boolean} options.scripts\r\n * @return {Element|TextNode|DocumentFragment}\r\n * @api public\r\n */\r\nexport default function dominate(html, {context = document, type = 'html', scripts = true} = {}) {\r\n    // Return an XML element if the type param is 'xml'\r\n    if (type.toLowerCase() === 'xml') {\r\n        return parseDocument(html, 'text/xml');\r\n    }\r\n    // Parse the HTML string for a tag name\r\n    const match = tagNameRe.exec(html);\r\n    // If no tag name exists, treat it as plain text\r\n    if (!match) {\r\n        return context.createTextNode(html);\r\n    }\r\n    // Get the tag name\r\n    const tag = match[1].toLowerCase();\r\n    // Parse the HTML string into a DOM node\r\n    const el = parse(context, tag, html.trim());\r\n    // If it's a script element, return it as it\r\n    // should always execute regardless of the\r\n    // `scripts` param\r\n    if (tag === 'script') {\r\n        return el;\r\n    }\r\n    // If `scripts` param is true, replace all script\r\n    // elements with a new script element to enable\r\n    // execution, otherwise remove the script elements\r\n    const elements = el.querySelectorAll('script');\r\n    for (let i = 0, len = elements.length, script, parent; i < len; i++) {\r\n        script = elements[i];\r\n        parent = script.parentNode;\r\n        if (scripts === false) {\r\n            parent.removeChild(script);\r\n        } else {\r\n            parent.replaceChild(copyScript(context, script), script);\r\n        }\r\n    }\r\n    return el;\r\n}\r\n"],"sourceRoot":"/source/"}