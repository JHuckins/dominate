{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","dominate.js","src/dominate.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","dominate","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length","1","isSVG","tag","svgTags","indexOf","isTaggedTemplate","args","_typeof","strings","Array","isArray","raw","copyAttributes","el","target","attr","attrs","attributes","len","setAttribute","name","value","copyScript","doc","script","createElement","async","text","textContent","parseDocument","markup","type","parser","DOMParser","newDoc","parseFromString","removeChild","documentElement","parseHTML","html","arguments","undefined","innerHTML","parseElements","supportsTemplate","template","importNode","content","wrap","wrapMap","_default","depth","lastChild","parse","supportsDOMParserHTML","_el","xml","_el2","firstChild","childNodes","frag","createDocumentFragment","appendChild","_arguments2","_ref","_ref$context","context","document","_ref$type","_ref$scripts","scripts","_ret","_arguments","prototype","slice","values","v","reduce","acc","str","join","toLowerCase","match","tagNameRe","exec","createTextNode","trim","parent","elements","querySelectorAll","parentNode","replaceChild","Object","defineProperty","Symbol","iterator","obj","constructor","thead","col","tr","td","tbody","tfoot","colgroup","caption","th","svgWrap"],"mappings":";CAAA,SAAAA,GAAA,GAAA,gBAAAC,UAAA,mBAAAC,QAAAA,OAAAD,QAAAD,QAAA,IAAA,kBAAAG,SAAAA,OAAAC,IAAAD,UAAAH,OAAA,CAAA,GAAAK,EAAAA,GAAA,mBAAAC,QAAAA,OAAA,mBAAAC,QAAAA,OAAA,mBAAAC,MAAAA,KAAAC,KAAAJ,EAAAK,SAAAV,MAAA,WAAA,MAAA,SAAAW,GAAAC,EAAAC,EAAAC,GAAA,QAAAC,GAAAC,EAAAC,GAAA,IAAAJ,EAAAG,GAAA,CAAA,IAAAJ,EAAAI,GAAA,CAAA,GAAAE,GAAA,kBAAAC,UAAAA,OAAA,KAAAF,GAAAC,EAAA,MAAAA,GAAAF,GAAA,EAAA,IAAAI,EAAA,MAAAA,GAAAJ,GAAA,EAAA,IAAAhB,GAAA,GAAAqB,OAAA,uBAAAL,EAAA,IAAA,MAAAhB,GAAAsB,KAAA,mBAAAtB,EAAA,GAAAuB,GAAAV,EAAAG,IAAAf,WAAAW,GAAAI,GAAA,GAAAQ,KAAAD,EAAAtB,QAAA,SAAAU,GAAA,GAAAE,GAAAD,EAAAI,GAAA,GAAAL,EAAA,OAAAI,GAAAF,EAAAA,EAAAF,IAAAY,EAAAA,EAAAtB,QAAAU,EAAAC,EAAAC,EAAAC,GAAA,MAAAD,GAAAG,GAAAf,QAAA,IAAA,GAAAmB,GAAA,kBAAAD,UAAAA,QAAAH,EAAA,EAAAA,EAAAF,EAAAW,OAAAT,IAAAD,EAAAD,EAAAE,GAAA,OAAAD,KAAAW,GAAA,SAAAP,EAAAjB,EAAAD,GCEA,YC2FA,SAAS0B,GAAMC,GACX,MAAgC,KAAzBC,EAAQC,QAAQF,GAW3B,QAASG,GAAiBC,GACtB,IAAKA,GAAwB,YAAhB,mBAAOA,GAAP,YAAAC,EAAOD,IAChB,OAAO,CAEX,IAAME,GAAUF,EAAK,EACrB,OACIE,IACAC,MAAMC,QAAQF,IACdC,MAAMC,QAAQF,EAAQG,MACA,gBAAfH,GAAQ,IACW,gBAAnBA,GAAQG,IAAI,KAClB,EAWT,QAASC,GAAeC,EAAIC,GAExB,IAAK,GAA+BC,GAD9BC,EAAQF,EAAOG,WACZvB,EAAI,EAAGwB,EAAMF,EAAMjB,OAAkBmB,EAAJxB,EAASA,IAC/CqB,EAAOC,EAAMtB,GACbmB,EAAGM,aAAaJ,EAAKK,KAAML,EAAKM,MAEpC,OAAOR,GAWX,QAASS,GAAWC,EAAKV,GACrB,GAAMW,GAASD,EAAIE,cAAc,SAGjC,OAFAD,GAAOE,OAAQ,EACfF,EAAOG,KAAOd,EAAGe,YACVhB,EAAeY,EAAQX,GAWlC,QAASgB,GAAcC,EAAQC,GAC3B,GAAMC,GAAS,GAAIC,WACbC,EAASF,EAAOG,gBAAgBL,EAAQC,EAC9C,OAAOG,GAAOE,YAAYF,EAAOG,iBAarC,QAASC,GAAUf,EAAKgB,GAAmB,GAAbrC,GAAasC,UAAAzC,QAAA,GAAA0C,SAAAD,UAAA,GAAP,MAAOA,UAAA,GACjC3B,EAAKU,EAAIE,cAAcvB,EAE7B,OADAW,GAAG6B,UAAYH,EACR1B,EAYX,QAAS8B,GAAcpB,EAAKrB,EAAKqC,GAG7B,GAAIK,IAAqB3C,EAAMC,GAAM,CAEjC,GAAM2C,GAAWtB,EAAIE,cAAc,WAInC,OAHAoB,GAASH,UAAYH,EAGdhB,EAAIuB,WAAWD,EAASE,SAAS,GAQ5C,IALA,GAAMC,GAAOC,EAAQ/C,IAAQ+C,EAAQC,SAEjCrC,EAAKyB,EAAUf,EAAKyB,EAAK,GAAKT,EAAOS,EAAK,IAE1CG,EAAQH,EAAK,GACVG,KACHtC,EAAKA,EAAGuC,SAEZ,OAAOvC,GAYX,QAASwC,GAAM9B,EAAKrB,EAAKqC,GAErB,GAAY,SAARrC,EAAgB,CAChB,GAAIoD,EACA,MAAOzB,GAAcU,EAAM,YAK/B,IAAMgB,GAAKjB,EAAUf,EAAKgB,EAAM,QAC1BiB,EAAM3B,EAAcU,EAAM,WAChC,OAAO3B,GAAe2C,EAAIC,GAG9B,GAAY,SAARtD,GAA0B,SAARA,EAAgB,CAClC,GAAMuD,GAAKnB,EAAUf,EAAKgB,EAAM,OAChC,OAAOkB,GAAGrB,YAAoB,SAARlC,EAAiBuD,EAAGC,WAAaD,EAAGL,WAG9D,GAAMvC,GAAK8B,EAAcpB,EAAKrB,EAAKqC,EAEnC,IAAY,WAARrC,EACA,MAAOoB,GAAWC,EAAKV,EAAG6C,WAG9B,IAA6B,IAAzB7C,EAAG8C,WAAW5D,OACd,MAAOc,GAAGuB,YAAYvB,EAAG6C,WAI7B,KADA,GAAME,GAAOrC,EAAIsC,yBACVhD,EAAG6C,YACNE,EAAKE,YAAYjD,EAAG6C,WAExB,OAAOE,GAcI,QAAS5E,GAASuD,GAAgE,GAAAwB,GAAAvB,UAAAwB,EAAAxB,UAAAzC,QAAA,GAAA0C,SAAAD,UAAA,MAAAA,UAAA,GAAAyB,EAAAD,EAAzDE,QAAAA,EAAyDzB,SAAAwB,EAA/CE,SAA+CF,EAAAG,EAAAJ,EAArCjC,KAAAA,EAAqCU,SAAA2B,EAA9B,OAA8BA,EAAAC,EAAAL,EAAtBM,QAAAA,EAAsB7B,SAAA4B,GAAZ,EAAYA,CAE7F,IAAIhE,EAAiBmC,WAAY,CAAA,GAAA+B,GAAA,WAAA,GAAAC,GAAA/D,MAAAgE,UAAAC,MAAA5E,KAAAiE,GACtBvD,EADsBgE,EAAA,GACVG,EADUH,EAAAE,MAAA,EAE7B,QAAAE,EAAO5F,EAASwB,EAAQG,IAAIkE,OAAO,SAACC,EAAKC,EAAKrF,GAAX,MAAiBoF,GAAOH,EAAOjF,EAAI,GAAIsF,KAAK,IAAMD,QAFxD,IAAA,YAAA,mBAAAR,GAAA,YAAAhE,EAAAgE,IAAA,MAAAA,GAAAK,EAKjC,GAA2B,QAAvB7C,EAAKkD,cACL,MAAOpD,GAAcU,EAAM,WAG/B,IAAM2C,GAAQC,EAAUC,KAAK7C,EAE7B,KAAK2C,EACD,MAAOhB,GAAQmB,eAAe9C,EAGlC,IAAMrC,GAAMgF,EAAM,GAEZrE,EAAKwC,EAAMa,EAAShE,EAAKqC,EAAK+C,OAIpC,IAAY,WAARpF,EACA,MAAOW,EAMX,KAAK,GAAkCW,GAAQ+D,EADzCC,EAAW3E,EAAG4E,iBAAiB,UAC5B/F,EAAI,EAAGwB,EAAMsE,EAASzF,OAA4BmB,EAAJxB,EAASA,IAC5D8B,EAASgE,EAAS9F,GAClB6F,EAAS/D,EAAOkE,WACZpB,KAAY,EACZiB,EAAOnD,YAAYZ,GAEnB+D,EAAOI,aAAarE,EAAW4C,EAAS1C,GAASA,EAGzD,OAAOX,GDhTX+E,OAAOC,eAAetH,EAAS,cAC3B8C,OAAO,GAGX,IAAId,GAA4B,kBAAXuF,SAAoD,gBAApBA,QAAOC,SAAwB,SAAUC,GAAO,aAAcA,IAAS,SAAUA,GAAO,MAAOA,IAAyB,kBAAXF,SAAyBE,EAAIC,cAAgBH,OAAS,eAAkBE,GAE1OzH,GAAAA,WCmQwBS,CA1QxB,IAAMmG,GAAY,YAKZvC,EAAmB,WAAauB,UAAS1C,cAAc,YAKvD6B,EAAyB,WAC3B,IACI,IAAK,GAAIrB,YAAaE,gBAAgB,GAAI,aACtC,OAAO,EAEb,MAAOlD,GACL,OAAO,MAUTgE,GACFiD,OAAQ,EAAG,UAAW,YACtBC,KAAM,EAAG,oBAAqB,uBAC9BC,IAAK,EAAG,iBAAkB,oBAC1BC,IAAK,EAAG,qBAAsB,yBAC9BnD,UAAW,EAAG,GAAI,IAEtBD,GAAQqD,MAAQrD,EAAQsD,MAAQtD,EAAQuD,SAAWvD,EAAQwD,QAAUxD,EAAQiD,MAC7EjD,EAAQyD,GAAKzD,EAAQoD,EAKrB,IAAMlG,IACF,UACA,eACA,gBACA,mBACA,SACA,WACA,OACA,OACA,UACA,gBACA,SACA,IACA,WACA,QACA,OACA,iBACA,SACA,OACA,WACA,OACA,UACA,UACA,WACA,iBACA,OACA,MACA,OACA,SACA,SACA,OACA,WACA,OACA,QACA,MACA,QAMEwG,GAAW,EAAG,2CAA4C,SAChExG,GAAQ0E,OAAO,SAAC7B,EAAM9C,GAAP,MAAgB+C,GAAQ/C,GAAO8C,GAAO2D,GD+NrDnI,EAAOD,QAAUA,EAAQ,qBAEd,IAAI","file":"dominate.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","/*! dominate v0.3.0 | https://github.com/ryanmorr/dominate */\n(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.dominate = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\nObject.defineProperty(exports, \"__esModule\", {\n    value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol ? \"symbol\" : typeof obj; };\n\nexports.default = dominate;\n/**\r\n * Regular expression to extract the tag name\r\n */\nvar tagNameRe = /<([\\w-]+)/;\n\n/**\r\n * Check if the browser supports the <template> element\r\n */\nvar supportsTemplate = 'content' in document.createElement('template');\n\n/**\r\n * Determine if `DOMParser` supports 'text/html'\r\n */\nvar supportsDOMParserHTML = function () {\n    try {\n        if (new DOMParser().parseFromString('', 'text/html')) {\n            return true;\n        }\n    } catch (e) {\n        return false;\n    }\n}();\n\n/**\r\n * Prevent the parser from ignoring certain\r\n * elements by wrapping them with the necessary\r\n * parent elements to appease XHTML compliance\r\n * courtesy of jQuery: https://github.com/jquery/jquery/blob/master/src/manipulation/wrapMap.js\r\n */\nvar wrapMap = {\n    thead: [1, '<table>', '</table>'],\n    col: [2, '<table><colgroup>', '</colgroup></table>'],\n    tr: [2, '<table><tbody>', '</tbody></table>'],\n    td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\n    _default: [0, '', '']\n};\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\nwrapMap.th = wrapMap.td;\n\n/**\r\n * SVG elements\r\n */\nvar svgTags = ['animate', 'animateColor', 'animateMotion', 'animateTransform', 'circle', 'clipPath', 'defs', 'desc', 'ellipse', 'foreignObject', 'filter', 'g', 'gradient', 'image', 'line', 'linearGradient', 'marker', 'mask', 'metadata', 'path', 'pattern', 'polygon', 'polyline', 'radialGradient', 'rect', 'set', 'stop', 'switch', 'symbol', 'text', 'textPath', 'tref', 'tspan', 'use', 'view'];\n\n/**\r\n * Add wrap to support SVG elements\r\n */\nvar svgWrap = [1, '<svg xmlns=\"http://www.w3.org/2000/svg\">', '</svg>'];\nsvgTags.reduce(function (wrap, tag) {\n    return wrapMap[tag] = wrap;\n}, svgWrap);\n\n/**\r\n * Is the tag an SVG tag\r\n *\r\n * @param {String} tag\r\n * @return {Boolean}\r\n * @api private\r\n */\nfunction isSVG(tag) {\n    return svgTags.indexOf(tag) !== -1;\n}\n\n/**\r\n * Are the passed arguments a result of a\r\n * tagged template literal invocation\r\n *\r\n * @param {Arguments} args\r\n * @return {Boolean}\r\n * @api private\r\n */\nfunction isTaggedTemplate(args) {\n    if (!args || (typeof args === 'undefined' ? 'undefined' : _typeof(args)) !== 'object') {\n        return false;\n    }\n    var strings = args[0];\n    return strings && Array.isArray(strings) && Array.isArray(strings.raw) && typeof strings[0] === 'string' && typeof strings.raw[0] === 'string' || false;\n}\n\n/**\r\n * Copy the attributes from one node to another\r\n *\r\n * @param {Element} el\r\n * @param {Element} target\r\n * @return {Element}\r\n * @api private\r\n */\nfunction copyAttributes(el, target) {\n    var attrs = target.attributes;\n    for (var i = 0, len = attrs.length, attr; i < len; i++) {\n        attr = attrs[i];\n        el.setAttribute(attr.name, attr.value);\n    }\n    return el;\n}\n\n/**\r\n * Create a script element that will execute\r\n *\r\n * @param {Document} doc\r\n * @param {Element} el\r\n * @return {Element}\r\n * @api private\r\n */\nfunction copyScript(doc, el) {\n    var script = doc.createElement('script');\n    script.async = true;\n    script.text = el.textContent;\n    return copyAttributes(script, el);\n}\n\n/**\r\n * Parse HTML and XML documents\r\n *\r\n * @param {String} markup\r\n * @param {String} type\r\n * @return {Element}\r\n * @api private\r\n */\nfunction parseDocument(markup, type) {\n    var parser = new DOMParser();\n    var newDoc = parser.parseFromString(markup, type);\n    return newDoc.removeChild(newDoc.documentElement);\n}\n\n/**\r\n * Parse HTML string using the proper parent\r\n * element\r\n *\r\n * @param {Document} doc\r\n * @param {String} html\r\n * @param {String} tag\r\n * @return {Element}\r\n * @api private\r\n */\nfunction parseHTML(doc, html) {\n    var tag = arguments.length <= 2 || arguments[2] === undefined ? 'div' : arguments[2];\n\n    var el = doc.createElement(tag);\n    el.innerHTML = html;\n    return el;\n}\n\n/**\r\n * Parse HTML elements\r\n *\r\n * @param {Document} doc\r\n * @param {String} tag\r\n * @param {String} html\r\n * @return {Element}\r\n * @api private\r\n */\nfunction parseElements(doc, tag, html) {\n    // Use the <template> element if it is supported and\n    // the tag is not an SVG element\n    if (supportsTemplate && !isSVG(tag)) {\n        // Create a template element to parse the HTML string\n        var template = doc.createElement('template');\n        template.innerHTML = html;\n        // Clone and return the document fragment within\n        // the template\n        return doc.importNode(template.content, true);\n    }\n    // Wrap the element in the appropriate container\n    var wrap = wrapMap[tag] || wrapMap._default;\n    // Parse HTML string\n    var el = parseHTML(doc, wrap[1] + html + wrap[2]);\n    // Descend through wrappers to get the right element\n    var depth = wrap[0];\n    while (depth--) {\n        el = el.lastChild;\n    }\n    return el;\n}\n\n/**\r\n * Parse an HMTL string into a DOM node\r\n *\r\n * @param {Document} doc\r\n * @param {String} tag\r\n * @param {String} html\r\n * @return {Element|DocumentFragment}\r\n * @api private\r\n */\nfunction parse(doc, tag, html) {\n    // Support <html> elements\n    if (tag === 'html') {\n        if (supportsDOMParserHTML) {\n            return parseDocument(html, 'text/html');\n        }\n        // Attributes of the <html> element do not get\n        // parsed using `innerHTML` here, so we parse it\n        // as XML and then copy the attributes\n        var _el = parseHTML(doc, html, 'html');\n        var xml = parseDocument(html, 'text/xml');\n        return copyAttributes(_el, xml);\n    }\n    // Support <body> and <head> elements\n    if (tag === 'head' || tag === 'body') {\n        var _el2 = parseHTML(doc, html, 'html');\n        return _el2.removeChild(tag === 'head' ? _el2.firstChild : _el2.lastChild);\n    }\n    // Support every other element\n    var el = parseElements(doc, tag, html);\n    // Support executable <script> elements\n    if (tag === 'script') {\n        return copyScript(doc, el.firstChild);\n    }\n    // Single element\n    if (el.childNodes.length === 1) {\n        return el.removeChild(el.firstChild);\n    }\n    // Use a document fragment for multiple elements\n    var frag = doc.createDocumentFragment();\n    while (el.firstChild) {\n        frag.appendChild(el.firstChild);\n    }\n    return frag;\n}\n\n/**\r\n * Convert a string into a DOM node\r\n *\r\n * @param {String} html\r\n * @param {Object} options\r\n * @param {Document} options.context\r\n * @param {String} options.type\r\n * @param {Boolean} options.scripts\r\n * @return {Element|TextNode|DocumentFragment}\r\n * @api public\r\n */\nfunction dominate(html) {\n    var _arguments2 = arguments;\n\n    var _ref = arguments.length <= 1 || arguments[1] === undefined ? {} : arguments[1];\n\n    var _ref$context = _ref.context;\n    var context = _ref$context === undefined ? document : _ref$context;\n    var _ref$type = _ref.type;\n    var type = _ref$type === undefined ? 'html' : _ref$type;\n    var _ref$scripts = _ref.scripts;\n    var scripts = _ref$scripts === undefined ? true : _ref$scripts;\n\n    // Check if it is a tagged template invocation\n    if (isTaggedTemplate(arguments)) {\n        var _ret = function () {\n            var _arguments = Array.prototype.slice.call(_arguments2);\n\n            var strings = _arguments[0];\n\n            var values = _arguments.slice(1);\n\n            return {\n                v: dominate(strings.raw.reduce(function (acc, str, i) {\n                    return acc + values[i - 1].join('') + str;\n                }))\n            };\n        }();\n\n        if ((typeof _ret === 'undefined' ? 'undefined' : _typeof(_ret)) === \"object\") return _ret.v;\n    }\n    // Return an XML element if the type param is 'xml'\n    if (type.toLowerCase() === 'xml') {\n        return parseDocument(html, 'text/xml');\n    }\n    // Parse the HTML string for a tag name\n    var match = tagNameRe.exec(html);\n    // If no tag name exists, treat it as plain text\n    if (!match) {\n        return context.createTextNode(html);\n    }\n    // Get the tag name\n    var tag = match[1];\n    // Parse the HTML string into a DOM node\n    var el = parse(context, tag, html.trim());\n    // If it's a script element, return it as it\n    // should always execute regardless of the\n    // `scripts` param\n    if (tag === 'script') {\n        return el;\n    }\n    // If `scripts` param is true, replace all script\n    // elements with a new script element to enable\n    // execution, otherwise remove the script elements\n    var elements = el.querySelectorAll('script');\n    for (var i = 0, len = elements.length, script, parent; i < len; i++) {\n        script = elements[i];\n        parent = script.parentNode;\n        if (scripts === false) {\n            parent.removeChild(script);\n        } else {\n            parent.replaceChild(copyScript(context, script), script);\n        }\n    }\n    return el;\n}\nmodule.exports = exports['default'];\n\n},{}]},{},[1])(1)\n});\n\n","/**\r\n * Regular expression to extract the tag name\r\n */\r\nconst tagNameRe = /<([\\w-]+)/;\r\n\r\n/**\r\n * Check if the browser supports the <template> element\r\n */\r\nconst supportsTemplate = 'content' in document.createElement('template');\r\n\r\n/**\r\n * Determine if `DOMParser` supports 'text/html'\r\n */\r\nconst supportsDOMParserHTML = (() => {\r\n    try {\r\n        if ((new DOMParser()).parseFromString('', 'text/html')) {\r\n            return true;\r\n        }\r\n    } catch (e) {\r\n        return false;\r\n    }\r\n})();\r\n\r\n/**\r\n * Prevent the parser from ignoring certain\r\n * elements by wrapping them with the necessary\r\n * parent elements to appease XHTML compliance\r\n * courtesy of jQuery: https://github.com/jquery/jquery/blob/master/src/manipulation/wrapMap.js\r\n */\r\nconst wrapMap = {\r\n    thead: [1, '<table>', '</table>'],\r\n    col: [2, '<table><colgroup>', '</colgroup></table>'],\r\n    tr: [2, '<table><tbody>', '</tbody></table>'],\r\n    td: [3, '<table><tbody><tr>', '</tr></tbody></table>'],\r\n    _default: [0, '', '']\r\n};\r\nwrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;\r\nwrapMap.th = wrapMap.td;\r\n\r\n/**\r\n * SVG elements\r\n */\r\nconst svgTags = [\r\n    'animate',\r\n    'animateColor',\r\n    'animateMotion',\r\n    'animateTransform',\r\n    'circle',\r\n    'clipPath',\r\n    'defs',\r\n    'desc',\r\n    'ellipse',\r\n    'foreignObject',\r\n    'filter',\r\n    'g',\r\n    'gradient',\r\n    'image',\r\n    'line',\r\n    'linearGradient',\r\n    'marker',\r\n    'mask',\r\n    'metadata',\r\n    'path',\r\n    'pattern',\r\n    'polygon',\r\n    'polyline',\r\n    'radialGradient',\r\n    'rect',\r\n    'set',\r\n    'stop',\r\n    'switch',\r\n    'symbol',\r\n    'text',\r\n    'textPath',\r\n    'tref',\r\n    'tspan',\r\n    'use',\r\n    'view'\r\n];\r\n\r\n/**\r\n * Add wrap to support SVG elements\r\n */\r\nconst svgWrap = [1, '<svg xmlns=\"http://www.w3.org/2000/svg\">', '</svg>'];\r\nsvgTags.reduce((wrap, tag) => (wrapMap[tag] = wrap), svgWrap);\r\n\r\n/**\r\n * Is the tag an SVG tag\r\n *\r\n * @param {String} tag\r\n * @return {Boolean}\r\n * @api private\r\n */\r\nfunction isSVG(tag) {\r\n    return svgTags.indexOf(tag) !== -1;\r\n}\r\n\r\n/**\r\n * Are the passed arguments a result of a\r\n * tagged template literal invocation\r\n *\r\n * @param {Arguments} args\r\n * @return {Boolean}\r\n * @api private\r\n */\r\nfunction isTaggedTemplate(args) {\r\n    if (!args || typeof args !== 'object') {\r\n        return false;\r\n    }\r\n    const strings = args[0];\r\n    return (\r\n        strings &&\r\n        Array.isArray(strings) &&\r\n        Array.isArray(strings.raw) &&\r\n        typeof strings[0] === 'string' &&\r\n        typeof strings.raw[0] === 'string'\r\n    ) || false;\r\n}\r\n\r\n/**\r\n * Copy the attributes from one node to another\r\n *\r\n * @param {Element} el\r\n * @param {Element} target\r\n * @return {Element}\r\n * @api private\r\n */\r\nfunction copyAttributes(el, target) {\r\n    const attrs = target.attributes;\r\n    for (let i = 0, len = attrs.length, attr; i < len; i++) {\r\n        attr = attrs[i];\r\n        el.setAttribute(attr.name, attr.value);\r\n    }\r\n    return el;\r\n}\r\n\r\n/**\r\n * Create a script element that will execute\r\n *\r\n * @param {Document} doc\r\n * @param {Element} el\r\n * @return {Element}\r\n * @api private\r\n */\r\nfunction copyScript(doc, el) {\r\n    const script = doc.createElement('script');\r\n    script.async = true;\r\n    script.text = el.textContent;\r\n    return copyAttributes(script, el);\r\n}\r\n\r\n/**\r\n * Parse HTML and XML documents\r\n *\r\n * @param {String} markup\r\n * @param {String} type\r\n * @return {Element}\r\n * @api private\r\n */\r\nfunction parseDocument(markup, type) {\r\n    const parser = new DOMParser();\r\n    const newDoc = parser.parseFromString(markup, type);\r\n    return newDoc.removeChild(newDoc.documentElement);\r\n}\r\n\r\n/**\r\n * Parse HTML string using the proper parent\r\n * element\r\n *\r\n * @param {Document} doc\r\n * @param {String} html\r\n * @param {String} tag\r\n * @return {Element}\r\n * @api private\r\n */\r\nfunction parseHTML(doc, html, tag = 'div') {\r\n    const el = doc.createElement(tag);\r\n    el.innerHTML = html;\r\n    return el;\r\n}\r\n\r\n/**\r\n * Parse HTML elements\r\n *\r\n * @param {Document} doc\r\n * @param {String} tag\r\n * @param {String} html\r\n * @return {Element}\r\n * @api private\r\n */\r\nfunction parseElements(doc, tag, html) {\r\n    // Use the <template> element if it is supported and\r\n    // the tag is not an SVG element\r\n    if (supportsTemplate && !isSVG(tag)) {\r\n        // Create a template element to parse the HTML string\r\n        const template = doc.createElement('template');\r\n        template.innerHTML = html;\r\n        // Clone and return the document fragment within\r\n        // the template\r\n        return doc.importNode(template.content, true);\r\n    }\r\n    // Wrap the element in the appropriate container\r\n    const wrap = wrapMap[tag] || wrapMap._default;\r\n    // Parse HTML string\r\n    let el = parseHTML(doc, wrap[1] + html + wrap[2]);\r\n    // Descend through wrappers to get the right element\r\n    let depth = wrap[0];\r\n    while (depth--) {\r\n        el = el.lastChild;\r\n    }\r\n    return el;\r\n}\r\n\r\n/**\r\n * Parse an HMTL string into a DOM node\r\n *\r\n * @param {Document} doc\r\n * @param {String} tag\r\n * @param {String} html\r\n * @return {Element|DocumentFragment}\r\n * @api private\r\n */\r\nfunction parse(doc, tag, html) {\r\n    // Support <html> elements\r\n    if (tag === 'html') {\r\n        if (supportsDOMParserHTML) {\r\n            return parseDocument(html, 'text/html');\r\n        }\r\n        // Attributes of the <html> element do not get\r\n        // parsed using `innerHTML` here, so we parse it\r\n        // as XML and then copy the attributes\r\n        const el = parseHTML(doc, html, 'html');\r\n        const xml = parseDocument(html, 'text/xml');\r\n        return copyAttributes(el, xml);\r\n    }\r\n    // Support <body> and <head> elements\r\n    if (tag === 'head' || tag === 'body') {\r\n        const el = parseHTML(doc, html, 'html');\r\n        return el.removeChild(tag === 'head' ? el.firstChild : el.lastChild);\r\n    }\r\n    // Support every other element\r\n    const el = parseElements(doc, tag, html);\r\n    // Support executable <script> elements\r\n    if (tag === 'script') {\r\n        return copyScript(doc, el.firstChild);\r\n    }\r\n    // Single element\r\n    if (el.childNodes.length === 1) {\r\n        return el.removeChild(el.firstChild);\r\n    }\r\n    // Use a document fragment for multiple elements\r\n    const frag = doc.createDocumentFragment();\r\n    while (el.firstChild) {\r\n        frag.appendChild(el.firstChild);\r\n    }\r\n    return frag;\r\n}\r\n\r\n/**\r\n * Convert a string into a DOM node\r\n *\r\n * @param {String} html\r\n * @param {Object} options\r\n * @param {Document} options.context\r\n * @param {String} options.type\r\n * @param {Boolean} options.scripts\r\n * @return {Element|TextNode|DocumentFragment}\r\n * @api public\r\n */\r\nexport default function dominate(html, {context = document, type = 'html', scripts = true} = {}) {\r\n    // Check if it is a tagged template invocation\r\n    if (isTaggedTemplate(arguments)) {\r\n        const [strings, ...values] = arguments;\r\n        return dominate(strings.raw.reduce((acc, str, i) => acc + (values[i - 1]).join('') + str));\r\n    }\r\n    // Return an XML element if the type param is 'xml'\r\n    if (type.toLowerCase() === 'xml') {\r\n        return parseDocument(html, 'text/xml');\r\n    }\r\n    // Parse the HTML string for a tag name\r\n    const match = tagNameRe.exec(html);\r\n    // If no tag name exists, treat it as plain text\r\n    if (!match) {\r\n        return context.createTextNode(html);\r\n    }\r\n    // Get the tag name\r\n    const tag = match[1];\r\n    // Parse the HTML string into a DOM node\r\n    const el = parse(context, tag, html.trim());\r\n    // If it's a script element, return it as it\r\n    // should always execute regardless of the\r\n    // `scripts` param\r\n    if (tag === 'script') {\r\n        return el;\r\n    }\r\n    // If `scripts` param is true, replace all script\r\n    // elements with a new script element to enable\r\n    // execution, otherwise remove the script elements\r\n    const elements = el.querySelectorAll('script');\r\n    for (let i = 0, len = elements.length, script, parent; i < len; i++) {\r\n        script = elements[i];\r\n        parent = script.parentNode;\r\n        if (scripts === false) {\r\n            parent.removeChild(script);\r\n        } else {\r\n            parent.replaceChild(copyScript(context, script), script);\r\n        }\r\n    }\r\n    return el;\r\n}\r\n"],"sourceRoot":"/source/"}